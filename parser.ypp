%{
	#include <iostream>
	#include <stdlib.h>
	#include "hw3_output.hpp"
	#include "source.hpp"
	#include "Symbol_Table.hpp"
	using namespace std;

	int var_num = 0;
	extern int yylineno;
	extern int yylex();
	int yyerror(const char * message);
	Symbol_Table symbol_table;
	bool while_flag;
	string RetType_flag;
	CodeBuffer& code_buffer = CodeBuffer::instance();

	string freshVar() {
		var_num++;
		return ("%" + to_string(var_num));
	}

%}

%start prog
%right ASSIGN
%left OR
%left AND
%left RELOP_EQ
%left RELOP_NE
%nonassoc RELOP_LT RELOP_GT RELOP_LE RELOP_GE
%left BINOP_ADD
%left BINOP_MUL
%left BINOP_DIV
%left BINOP_SUB
%right NOT
%left LPAREN RPAREN LBRACE RBRACE
%nonassoc IF WHILE RETURN BREAK CONTINUE INT BYTE BOOL STRING B ENUM SC VOID TRUE FALSE COMMA
%nonassoc<id> ID
%nonassoc<num> NUM
%right ELSE

%type<ret_type> RetType
%type<formals> Formals
%type<formals_list> FormalsList
%type<formal_decl> FormalDecl
%type<enumerator_list> EnumeratorList
%type<enumerator> Enumerator
%type<statements> Statements
%type<statement> Statement
%type<call> Call
%type<exp_list> ExpList
%type<type> Type
%type<enum_type> EnumType
%type<exp> Exp
%type<bool_exp> BoolExp
%type<m> M;
%type<n> N;

%%

prog:	OpenScope InsertFunc Enums Funcs{
			try{
				symbol_table.validMain();
			}catch(Symbol_Table::ST_errorMainMissing& e){
				output::errorMainMissing();
				exit(0);
			}
			symbol_table.closeScope();
		}
;
Funcs:	/*epsilon*/{}
		| FuncDecl Funcs{}
;
FuncDecl:	RetType {
				RetType_flag = $1.get_type();
			} ID LPAREN Formals RPAREN{
				try{
					symbol_table.insertFunc($3.get_id(), $1.get_type(), $5.get_params_type());
				}catch(Symbol_Table::ST_def& e){
				//function already exits
					output::errorDef(yylineno, e.get_raised_id());
					exit(0);
				}
				symbol_table.openScope();
				try{
					symbol_table.insertFuncParams($5.get_params_type(), $5.get_params_ids());
					}catch(Symbol_Table::ST_def& e){
						//the id of one of the params already exists
						output::errorDef(yylineno, e.get_raised_id());
						exit(0);
					}catch(Symbol_Table::ST_mismatch& e){
						//if the
						output::errorMismatch(yylineno);
						exit(0);
					}catch(Symbol_Table::ST_undefEnum& e){
						// enum doesnt exist
						output::errorUndefEnum(yylineno , e.get_raised_id());
						exit(0);
					}
			} LBRACE Statements RBRACE CloseScope {
				if ($9.get_type()== "VOID" && $1.get_type() != "VOID"){
					output::errorMismatch(yylineno);
					exit(0);
				}
			}
;

Enums:	/*epsilon*/{}
		| EnumDecl Enums{}
;
EnumDecl: ENUM ID LBRACE EnumeratorList RBRACE SC{
			try{
			symbol_table.insertEnumType($2.get_id(), $4.get_enumVector());
			}catch(Symbol_Table::ST_def& e){
				output::errorDef(yylineno, e.get_raised_id());
				exit(0);
			}
		}
;
RetType:	Type{
				$$.set_type($1.get_type());
			}
			|VOID{
				$$.set_type("VOID");
			}
;
Formals:	/*epsilon*/{
				$$.reset();
			}
			|FormalsList{
				$$.join_lists($1);
			}
;
FormalsList: FormalDecl{
				$$.reset();
				$$.insert($1);
			}
			 |FormalDecl COMMA FormalsList{
				$$.reset();
				$$.join_lists($3);
				$$.insert($1);
			 }
;
FormalDecl:	Type ID{
				$$.set_type($1.get_type());
				$$.set_id($2.get_id());
			}
			|EnumType ID{
				$$.set_type($1.get_type());
				$$.set_id($2.get_id());
			}
;
EnumeratorList:	Enumerator{
					$$.reset();
					$$.insert($1);
				}
				|EnumeratorList COMMA Enumerator{
					$$.reset();
					$$.join_lists($1);
					$$.insert($3);
				}
;
Enumerator: ID{
				$$.set_id($1.get_id());
			}
;
Statements:	Statement{
				$$.set_type($1.get_type());
			}
			|Statements Statement{
				$$.set_type2($1.get_type(), $2.get_type());
			}
;
Statement:	LBRACE OpenScope Statements CloseScope RBRACE{
				$$.set_type($3.get_type());
			}
			|Type ID SC{
				try{
					symbol_table.insert($2.get_id(), $1.get_type());
				}catch(Symbol_Table::ST_def& e){
					output::errorDef(yylineno, e.get_raised_id());
					exit(0);
				}
				$$.set_type("VOID");
			}
			|EnumType ID SC{
				try{
					symbol_table.insertEnumVar($2.get_id(),$1.get_type());
				}catch(Symbol_Table::ST_undefEnum& e){
				// the type doesnt exists
					output::errorUndefEnum(yylineno , e.get_raised_id());
					exit(0);
				}catch(Symbol_Table::ST_def& e){
				//the id exists:
					output::errorDef(yylineno, e.get_raised_id());
					exit(0);
				}
				$$.set_type("VOID");
			}
			|EnumDecl{
				$$.set_type("VOID");
			}
			|Type ID ASSIGN Exp SC{
				if ($1.get_type()!=$4.get_type() && !($4.get_type() == "BYTE" && $1.get_type() == "INT")){
					output::errorMismatch(yylineno);
					exit(0);
				}
				try{
					symbol_table.insert($2.get_id(), $1.get_type());
				}catch(Symbol_Table::ST_def& e){ // the id is used already
					output::errorDef(yylineno, e.get_raised_id());
					exit(0);
				}
				$$.set_type("VOID");
			}
			|BOOL ID ASSIGN BoolExp SC{
            				try{
            					symbol_table.insert($2.get_id(), "BOOL");
            				}catch(Symbol_Table::ST_def& e){ // the id is used already
            					output::errorDef(yylineno, e.get_raised_id());
            					exit(0);
            				}
            				$$.set_type("VOID");
            			}
			|EnumType ID ASSIGN Exp SC{
				try{
					symbol_table.insertEnumVar($2.get_id(), $1.get_type(), $4.get_enumVal());
				}catch(Symbol_Table::ST_undefEnum& e){
				// if the enum type doesnt exist
					output::errorUndefEnum(yylineno , e.get_raised_id());
					exit(0);
				}catch(Symbol_Table::ST_def& e){
				// id already exists
					output::errorDef(yylineno, e.get_raised_id());
					exit(0);
				}catch(Symbol_Table::ST_undefEnumValue& e){
				//the value given to the variable isn't part of the enum type
					output::errorUndefEnumValue(yylineno,$2.get_id());
					exit(0);
				}
				if ($4.get_type() != $1.get_type()){
					output::errorUndefEnumValue(yylineno, $2.get_id());
					exit(0);
				}
				$$.set_type("VOID");
			}
			|ID ASSIGN Exp SC{
				try{
					if ( symbol_table.get_datatype($1.get_id())!= ENUM_VAR && symbol_table.get_datatype($1.get_id()) != VAR){
						// if the id doesnt exist
						output::errorUndef(yylineno,$1.get_id());
						exit(0);
					}
					string type_of_id = symbol_table.get_var_type($1.get_id());
					if (symbol_table.get_datatype($1.get_id()) == ENUM_VAR && type_of_id != $3.get_type()){
						output::errorUndefEnumValue(yylineno,$1.get_id());
						exit(0);
					}
					if (type_of_id != $3.get_type() && !(type_of_id == "INT" && $3.get_type() == "BYTE")){
						output::errorMismatch(yylineno);
						exit(0);
					}
				}catch(Symbol_Table::ST_undef& e){
					// if the id doesnt exist
					output::errorUndef(yylineno,e.get_raised_id());
					exit(0);
				}

				$$.set_type("VOID");
			}
			|Call SC{
				$$.set_type("VOID");
			}
			|RETURN SC{
				if (RetType_flag != "VOID"){
					output::errorMismatch(yylineno);
					exit(0);
				}
				$$.set_type("VOID");
			}
			|RETURN Exp SC{
				if ((RetType_flag != $2.get_type() && !( RetType_flag == "INT" && $2.get_type() == "BYTE")) || $2.get_type() == "VOID"){
					output::errorMismatch(yylineno);
					exit(0);
				}
				$$.set_type($2.get_type());
			}
			|IF LPAREN BoolExp RPAREN OpenScope M Statement CloseScope {
				$$.set_type($7.get_type());

				//LLVM:
/*
                int next = code_buffer.emit("br label @");
                code_buffer.bpatch($3.get_true_list(), $6.get_quad());
                vector<pair<int,BranchLabelIndex>> new_list = CodeBuffer::makelist(pair<int,BranchLabelIndex>(next, FIRST));
                vector<pair<int,BranchLabelIndex>> merged_list = CodeBuffer::merge($3.get_false_list(), new_list);
                $$.set_next_list(merged_list);
*/
			}
			|IF LPAREN BoolExp RPAREN OpenScope M Statement CloseScope ELSE N M OpenScope Statement CloseScope {
				$$.set_type2($7.get_type(), $13.get_type());

				//LLVM:
/*
				int next = code_buffer.emit("br label @");
                code_buffer.bpatch($3.get_true_list(), $6.get_quad());
                code_buffer.bpatch($3.get_false_list(), $11.get_quad());
                vector<pair<int,BranchLabelIndex>> new_list = CodeBuffer::makelist(pair<int,BranchLabelIndex>(next, FIRST));
                vector<pair<int,BranchLabelIndex>> merged_list = CodeBuffer::merge($10.get_next_list(), new_list);
                $$.set_next_list(merged_list);
*/
			}
			|WHILE LPAREN BoolExp RPAREN TurnOnWhile OpenScope Statement TurnOffWhile CloseScope{
				$$.set_type($7.get_type());
			}
			|BREAK SC{
				if (!while_flag){
					output::errorUnexpectedBreak(yylineno);
					exit(0);
				}
				$$.set_type("VOID");
			}
			|CONTINUE SC{
				if (!while_flag){
					output::errorUnexpectedContinue(yylineno);
					exit(0);
				}
				$$.set_type("VOID");
			}
;
Call:	ID LPAREN ExpList RPAREN{
			try{
				symbol_table.using_func($1.get_id(), $3.get_types_vector());
			}
			catch(Symbol_Table::ST_undefFunc& e){
			// the function doesn't exist
			output::errorUndefFunc(yylineno, e.get_raised_id());
			exit(0);
			}
			catch(Symbol_Table::ST_prototypeMismatch& e) {
			// there is prototypeMismatch
			output::errorPrototypeMismatch(yylineno, $1.get_id(), symbol_table.get_func_types($1.get_id()));
			exit(0);
			}
			$$.set_type(symbol_table.get_func_retType($1.get_id()));
}
		|ID LPAREN RPAREN{
			vector<string>* type_list = new vector<string>();
			try{
				symbol_table.using_func($1.get_id(), *type_list);
			}
			catch(Symbol_Table::ST_undefFunc& e){
			// the function doesn't exist
				output::errorUndefFunc(yylineno, e.get_raised_id());
				exit(0);
			}
			catch(Symbol_Table::ST_prototypeMismatch& e){
			//there is prototypeMismatch
				output::errorPrototypeMismatch(yylineno, $1.get_id(), symbol_table.get_func_types($1.get_id()));
				exit(0);
			}
			$$.set_type(symbol_table.get_func_retType($1.get_id()));
		}
;
ExpList:	Exp{
				$$.reset();
				$$.insert($1);
			}
			|Exp COMMA ExpList{
				$$.reset();
				$$.join_lists($3);
				$$.insert($1);
			}
;
Type:	INT{
			$$.set_type("INT");
		}
		|BYTE{
			$$.set_type("BYTE");
		}
		|BOOL{
			$$.set_type("BOOL");
		}
;
EnumType:	ENUM ID{
				$$.set_type($2.get_id());
			}
;
Exp:	LPAREN Exp RPAREN{
			$$.reset();
			$$.set_type($2.get_type());
		}
		|Exp BINOP_MUL Exp{
			$$.reset();
			if (($1.get_type()!="INT" && $1.get_type()!="BYTE") || ($3.get_type()!="INT" && $3.get_type()!="BYTE")){
				output::errorMismatch(yylineno);
				exit(0);
			}
			if ($1.get_type() == "INT" || $3.get_type() == "INT"){
				$$.set_type("INT");
			}
			else{
				$$.set_type("BYTE");
			}
			string i_type = "i_type";
			if ($1.get_type()== "BYTE" && $3.get_type()== "BYTE"){
				i_type = "i8";
			}
			else{
				i_type = "i32";
			}
			string* new_place = new string(freshVar());
			$$.set_place(*new_place);
			const string my_string3 =  *new_place + " = mul " + i_type + " " + $1.get_place() + ", " + $3.get_place();
			code_buffer.emit(my_string3);
		}
		|Exp BINOP_DIV Exp{
			$$.reset();
			if (($1.get_type()!="INT" && $1.get_type()!="BYTE") || ($3.get_type()!="INT" && $3.get_type()!="BYTE")){
				output::errorMismatch(yylineno);
				exit(0);
			}
			if ($1.get_type() == "INT" || $3.get_type() == "INT"){
				$$.set_type("INT");
			}
			else{
				$$.set_type("BYTE");
			}
			string i_type = "i_type";
			if ($1.get_type()== "BYTE" && $3.get_type()== "BYTE"){
				i_type = "i8";
			}
			else{
				i_type = "i32";
			}
			string* new_place = new string(freshVar());
			$$.set_place(*new_place);
			const string my_string3 =  *new_place + " = div " + i_type + " " + $1.get_place() + ", " + $3.get_place();
			code_buffer.emit(my_string3);
		}
		|Exp BINOP_ADD Exp{
			$$.reset();
			if (($1.get_type()!="INT" && $1.get_type()!="BYTE") || ($3.get_type()!="INT" && $3.get_type()!="BYTE")){
				output::errorMismatch(yylineno);
				exit(0);
			}
			if ($1.get_type() == "INT" || $3.get_type() == "INT"){
				$$.set_type("INT");
			}
			else{
				$$.set_type("BYTE");
			}
			string i_type = "i_type";
			if ($1.get_type()== "BYTE" && $3.get_type()== "BYTE"){
				i_type = "i8";
			}
			else{
				i_type = "i32";
			}
			string* new_place = new string(freshVar());
			$$.set_place(*new_place);
			const string my_string3 =  *new_place + " = add " + i_type + " " + $1.get_place() + ", " + $3.get_place();
			code_buffer.emit(my_string3);
		}
		|Exp BINOP_SUB Exp{
			$$.reset();
			if (($1.get_type()!="INT" && $1.get_type()!="BYTE") || ($3.get_type()!="INT" && $3.get_type()!="BYTE")){
				output::errorMismatch(yylineno);
				exit(0);
			}
			if ($1.get_type() == "INT" || $3.get_type() == "INT"){
				$$.set_type("INT");
			}
			else{
				$$.set_type("BYTE");
			}
			string i_type = "i_type";
			if ($1.get_type()== "BYTE" && $3.get_type()== "BYTE"){
				i_type = "i8";
			}
			else{
				i_type = "i32";
			}
			string* new_place = new string(freshVar());
			$$.set_place(*new_place);
			const string my_string3 =  *new_place + " = sub " + i_type + " " + $1.get_place() + ", " + $3.get_place();
			code_buffer.emit(my_string3);
		}
		|ID{
			$$.reset();
			try{
				$$.set_type(symbol_table.get_var_type($1.get_id()));
			}catch(Symbol_Table::ST_undef& e){
				output::errorUndef(yylineno, e.get_raised_id());
				exit(0);
			}
			$$.set_enumVal($1.get_id());
			string type = symbol_table.get_var_type($1.get_id());
			string i_type;
			if (type == "BOOL") {
			    i_type = "i1";
			}
			else if (type == "BYTE") {
				i_type = "i8";
			}
			else if(type == "INT") {
				i_type = "i32";
			}
			else {
			    i_type = "ERROR!!!";
			}
			int offset = symbol_table.get_offset($1.get_id());
			string reg1 = freshVar();
			const string my_string1 = reg1 + " = getelementptr i32, i32* %stack, " + i_type + " " + to_string(offset);
			code_buffer.emit(my_string1);
			string reg2 = freshVar();
			const string my_string = reg2 + " = load " + i_type + "* " + reg1;
			code_buffer.emit( my_string);
			$$.set_place(reg2);
		}
		|Call{
			$$.reset();
			$$.set_type($1.get_type());
		}
		|NUM{
			$$.reset();
			$$.set_enumVal($1.get_value());
			$$.set_type("INT");
			$$.set_place($1.get_value());
		}
		|NUM B {
			$$.reset();
			$$.set_enumVal($1.get_value());
			if ($1.get_type() != "BYTE"){
				output::errorByteTooLarge(yylineno, $1.get_value());
				exit(0);
			}
			$$.set_type("BYTE");
			$$.set_place($1.get_value());
		}
		|STRING {
			$$.reset();
			$$.set_type("STRING");
		}
		|LPAREN Type RPAREN Exp {
			$$.reset();
			try{
			if((symbol_table.get_datatype($4.get_enumVal()) != ENUM_VAR) && (symbol_table.get_datatype($4.get_enumVal()) != ENUM_VAL)) {
				output::errorMismatch(yylineno);
				exit(0);
			}
			}catch(Symbol_Table::ST_undef& e) {
                output::errorUndef(yylineno, e.get_raised_id());
              	exit(0);
            }
			if ($2.get_type() != "INT"){
				output::errorMismatch(yylineno);
         		exit(0);
			}
			$$.set_type("INT");
		}
;
BoolExp: Exp {
            //$$.BoolExp_reset();
			if ($1.get_type() != "BOOL") {
				output::errorMismatch(yylineno);
				exit(0);
				}

			}
		|TRUE {
			$$.reset();
			$$.set_type("BOOL");

		}
		|FALSE {
			$$.reset();
			$$.set_type("BOOL");
		}
		|NOT Exp {
			$$.reset();
			if ($2.get_type() != "BOOL" ) {
				output::errorMismatch(yylineno);
         		exit(0);
			}
			$$.set_type("BOOL");
		}
		|Exp AND M Exp {
			$$.reset();
			if ($1.get_type() != "BOOL" || $4.get_type() != "BOOL" ){
				output::errorMismatch(yylineno);
         		exit(0);
			}
			$$.set_type("BOOL");
/*
            //LLVM:
            code_buffer.bpatch($1.get_true_list(), $3.get_quad());
            vector<pair<int,BranchLabelIndex>> merged_list = CodeBuffer::merge($1.get_false_list(), $4.get_false_list());
            $$.set_false_list(merged_list);
            $$.set_true_list($4.get_true_list());
*/
		}
		|Exp OR M Exp {
			$$.reset();
			if ($1.get_type() != "BOOL" || $4.get_type() != "BOOL" ) {
				output::errorMismatch(yylineno);
         		exit(0);
			}
			$$.set_type("BOOL");
/*
            //LLVM:
            code_buffer.bpatch($1.get_false_list(), $3.get_quad());
            vector<pair<int,BranchLabelIndex>> merged_list = CodeBuffer::merge($1.get_true_list(), $4.get_true_list());
            $$.set_true_list(merged_list);
            $$.set_false_list($4.get_false_list());
*/
		}
		|Exp RELOP_EQ Exp {
			$$.reset();
			if (($1.get_type() != "INT" && $1.get_type() != "BYTE") || ($3.get_type() != "INT" && $3.get_type() != "BYTE")) {
				output::errorMismatch(yylineno);
         		exit(0);
			}
			$$.set_type("BOOL");

			//LLVM:
			string reg = freshVar();
			string str = reg + " = icmp eq i32 " + ($1.get_place()) + ", " + ($3.get_place());
			int line = code_buffer.emit(str);
			string str2 = "br i1 " + reg + ", label @, label @";
			int next = code_buffer.emit(str2);
			//add true_list and false_list, maybe also add place
		}
		|Exp RELOP_NE Exp {
        	$$.reset();
        	if (($1.get_type() != "INT" && $1.get_type() != "BYTE") || ($3.get_type() != "INT" && $3.get_type() != "BYTE")) {
        		output::errorMismatch(yylineno);
               	exit(0);
        	}
        	$$.set_type("BOOL");

			//LLVM:
			string reg = freshVar();
			string str = reg + " = icmp ne i32 " + ($1.get_place()) + ", " + ($3.get_place());
			int line = code_buffer.emit(str);
			string str2 = "br i1 " + reg + ", label @, label @";
			int next = code_buffer.emit(str2);
			//add true_list and false_list, maybe also add place
        }
		|Exp RELOP_LT Exp {
			$$.reset();
			if (($1.get_type()!= "INT" && $1.get_type()!= "BYTE") || ($3.get_type()!= "INT" && $3.get_type()!= "BYTE")){
				output::errorMismatch(yylineno);
         		exit(0);
			}
			$$.set_type("BOOL");

			//LLVM:
			string reg = freshVar();
			string str;
			if ($1.get_type() == "BYTE" && $3.get_type() == "BYTE")
			    str = reg + " = icmp ult i32 " + ($1.get_place()) + ", " + ($3.get_place());
			else
			    str = reg + " = icmp slt i32 " + ($1.get_place()) + ", " + ($3.get_place());
			int line = code_buffer.emit(str);
			string str2 = "br i1 " + reg + ", label @, label @";
			int next = code_buffer.emit(str2);
			//add true_list and false_list, maybe also add place
		}
		|Exp RELOP_GT Exp {
			$$.reset();
			if (($1.get_type()!= "INT" && $1.get_type()!= "BYTE") || ($3.get_type()!= "INT" && $3.get_type()!= "BYTE")){
				output::errorMismatch(yylineno);
         		exit(0);
			}
			$$.set_type("BOOL");

			//LLVM:
			string reg = freshVar();
			string str;
			if ($1.get_type() == "BYTE" && $3.get_type() == "BYTE")
			    str = reg + " = icmp ugt i32 " + ($1.get_place()) + ", " + ($3.get_place());
			else
			    str = reg + " = icmp sgt i32 " + ($1.get_place()) + ", " + ($3.get_place());
			int line = code_buffer.emit(str);
			string str2 = "br i1 " + reg + ", label @, label @";
			int next = code_buffer.emit(str2);
			//add true_list and false_list, maybe also add place
		}
		|Exp RELOP_LE Exp {
			$$.reset();
			if (($1.get_type()!= "INT" && $1.get_type()!= "BYTE") || ($3.get_type()!= "INT" && $3.get_type()!= "BYTE")){
				output::errorMismatch(yylineno);
         		exit(0);
			}
			$$.set_type("BOOL");

			//LLVM:
			string reg = freshVar();
			string str;
			if ($1.get_type() == "BYTE" && $3.get_type() == "BYTE")
			    str = reg + " = icmp ule i32 " + ($1.get_place()) + ", " + ($3.get_place());
			else
			    str = reg + " = icmp sle i32 " + ($1.get_place()) + ", " + ($3.get_place());
			int line = code_buffer.emit(str);
			string str2 = "br i1 " + reg + ", label @, label @";
			int next = code_buffer.emit(str2);
			//add true_list and false_list, maybe also add place
		}
		|Exp RELOP_GE Exp {
			$$.reset();
			if (($1.get_type()!= "INT" && $1.get_type()!= "BYTE") || ($3.get_type()!= "INT" && $3.get_type()!= "BYTE")){
				output::errorMismatch(yylineno);
         		exit(0);
			}
			$$.set_type("BOOL");

			//LLVM:
			string reg = freshVar();
			string str;
			if ($1.get_type() == "BYTE" && $3.get_type() == "BYTE")
			    str = reg + " = icmp uge i32 " + ($1.get_place()) + ", " + ($3.get_place());
			else
			    str = reg + " = icmp sge i32 " + ($1.get_place()) + ", " + ($3.get_place());
			int line = code_buffer.emit(str);
			string str2 = "br i1 " + reg + ", label @, label @";
			int next = code_buffer.emit(str2);
			//add true_list and false_list, maybe also add place
		}
;
InsertFunc:	/*epsilon*/ {
				while_flag = false;
				vector<string> param1 = {"STRING"};
				vector<string> param2 = {"INT"};
				symbol_table.insertFunc("print", "VOID", param1);
				symbol_table.insertFunc("printi", "VOID", param2);
			}
;
OpenScope: /*epsilon*/ {
			symbol_table.openScope();
		}
;
CloseScope: /*epsilon*/ {
	try{
			symbol_table.closeScope();
		}catch(Symbol_Table::ST_empty){
			printf("wrong go out");
			exit(0);
		}
}
;
TurnOnWhile: /*epsilon*/ {
			while_flag = true;
		}
;
TurnOffWhile: /*epsilon*/ {
			while_flag = false;
		}
;

M: /*epsilon*/ {
            string str = code_buffer.genLabel();
			$$.set_quad(str);
		}
;

N: /*epsilon*/ {
			int next = code_buffer.emit("br label @");
			vector<pair<int,BranchLabelIndex>> new_list = CodeBuffer::makelist(pair<int,BranchLabelIndex>(next, FIRST));
            $$.set_next_list(new_list);
		}
;
%%

int yyerror(const char * message) {
		output::errorSyn(yylineno);
		exit(0);
	}


int main() {
	int y = yyparse();
	//code_buffer.printCodeBuffer();
	return y;
}