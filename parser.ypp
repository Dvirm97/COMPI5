%{
	#include <iostream>
	#include <stdlib.h>
	#include "hw3_output.hpp"
	#include "source.hpp"
	#include "Symbol_Table.hpp"
	using namespace std;

	int var_num = 0;
	int string_num = 0;
	extern int yylineno;
	extern int yylex();
	int yyerror(const char * message);
	Symbol_Table symbol_table;
	int while_flag;
	string RetType_flag;
	CodeBuffer& code_buffer = CodeBuffer::instance();

	string freshVar() {
		var_num++;
		return ("%r" + to_string(var_num));
	}
	string freshNum(){
		string_num++;
		return to_string(string_num);
	}
	

%}

%start prog
%right ASSIGN
%left OR
%left AND
%left RELOP_EQ
%left RELOP_NE
%nonassoc RELOP_LT RELOP_GT RELOP_LE RELOP_GE
%left BINOP_ADD
%left BINOP_SUB
%left BINOP_DIV BINOP_MUL
%right NOT
%left LPAREN RPAREN LBRACE RBRACE
%nonassoc IF WHILE RETURN BREAK CONTINUE INT BYTE BOOL B ENUM SC VOID TRUE FALSE COMMA
%nonassoc<id> ID
%nonassoc<num> NUM
%nonassoc<my_string> STRING
%right ELSE

%type<ret_type> RetType
%type<formals> Formals
%type<formals_list> FormalsList
%type<formal_decl> FormalDecl
%type<enumerator_list> EnumeratorList
%type<enumerator> Enumerator
%type<statements> Statements
%type<statement> Statement
%type<call> Call
%type<exp_list> ExpList
%type<type> Type
%type<enum_type> EnumType
%type<exp> Exp
%type<bool_exp> BoolExp
%type<m> M;
%type<n> N;

%%

prog:	OpenScope InsertFunc Enums Funcs{
			try{
				symbol_table.validMain();
			}catch(Symbol_Table::ST_errorMainMissing& e){
				output::errorMainMissing();
				exit(0);
			}
			symbol_table.closeScope();
		}
;
Funcs:	/*epsilon*/{}
		| FuncDecl Funcs{}
;
FuncDecl:	RetType {
				RetType_flag = $1.get_type();
			} ID LPAREN Formals RPAREN{
				try{
					symbol_table.insertFunc($3.get_id(), $1.get_type(), $5.get_params_type());
				}catch(Symbol_Table::ST_def& e){
				//function already exits
					output::errorDef(yylineno, e.get_raised_id());
					exit(0);
				}
				symbol_table.openScope();
				try{
					symbol_table.insertFuncParams($5.get_params_type(), $5.get_params_ids());
					}catch(Symbol_Table::ST_def& e){
						//the id of one of the params already exists
						output::errorDef(yylineno, e.get_raised_id());
						exit(0);
					}catch(Symbol_Table::ST_mismatch& e){
						//if the
						output::errorMismatch(yylineno);
						exit(0);
					}catch(Symbol_Table::ST_undefEnum& e){
						// enum doesnt exist
						output::errorUndefEnum(yylineno , e.get_raised_id());
						exit(0);
					}
					string return_type = "return_type";
					if ($1.get_type() == "VOID"){
						return_type = "void";
					}else{
						return_type = "i32";
					}	
					string my_string_param = "";
					string my_param_list = "";
					vector<string>& params_type_list = $5.get_params_type();
					vector<string>& params_id_list = $5.get_params_ids();
					string param_type = "";
					vector<string> params_regs;
					for(int i = 0; i < params_type_list.size(); i++){
						if (params_type_list[i] == "VOID"){
							param_type = "void";
						}
						else {
							param_type = "i32";
						}
						string reg_par = freshVar();
						my_string_param += param_type + " " + reg_par;
						params_regs.push_back(reg_par);
						if (i < params_type_list.size()-1){
							my_string_param += ", ";
						}
					}
					string my_string = "define " + return_type + " @" + $3.get_id()+ "(" + my_string_param + "){";
					code_buffer.emit(my_string);
					for (int i = 0; i < params_type_list.size(); i++){
						string new_reg = freshVar();
						code_buffer.emit( new_reg + " = alloca i32 ");
						code_buffer.emit(" store i32 " + params_regs[i] + ", i32* " + new_reg);
					}
					code_buffer.emit("%stack = alloca i32, i32 50");
			} LBRACE Statements RBRACE CloseScope {
				if ($9.get_type()== "VOID" && $1.get_type() != "VOID"){
					output::errorMismatch(yylineno);
					exit(0);
				}
				if($1.get_type() == "VOID") {
						code_buffer.emit("ret void");
				}
				else code_buffer.emit("ret i32 0");
				code_buffer.emit("}");
			}
;
Enums:	/*epsilon*/{}
		| EnumDecl Enums{}
;
EnumDecl: ENUM ID LBRACE EnumeratorList RBRACE SC{
			try{
			symbol_table.insertEnumType($2.get_id(), $4.get_enumVector());
			}catch(Symbol_Table::ST_def& e){
				output::errorDef(yylineno, e.get_raised_id());
				exit(0);
			}
		}
;
RetType:	Type{
				$$.set_type($1.get_type());
			}
			|VOID{
				$$.set_type("VOID");
			}
;
Formals:	/*epsilon*/{
				$$.reset();
			}
			|FormalsList{
				$$.join_lists($1);
			}
;
FormalsList: FormalDecl{
				$$.reset();
				$$.insert($1);
			}
			 |FormalDecl COMMA FormalsList{
				$$.reset();
				$$.join_lists($3);
				$$.insert($1);
			 }
;
FormalDecl:	Type ID{
				$$.set_type($1.get_type());
				$$.set_id($2.get_id());
			}
			|EnumType ID{
				$$.set_type($1.get_type());
				$$.set_id($2.get_id());
			}
;
EnumeratorList:	Enumerator{
					$$.reset();
					$$.insert($1);
				}
				|EnumeratorList COMMA Enumerator{
					$$.reset();
					$$.join_lists($1);
					$$.insert($3);
				}
;
Enumerator: ID{
				$$.set_id($1.get_id());
			}
;
Statements:	Statement {
				$$.set_type($1.get_type());

                //LLVM:
                $$.set_break_list($1.get_break_list());
                $$.set_continue_list($1.get_continue_list());

			}
			|Statements Statement {
				$$.set_type2($1.get_type(), $2.get_type());

				//LLVM:
				vector<pair<int,BranchLabelIndex>> b_list = CodeBuffer::merge($1.get_break_list(), $2.get_break_list());
				vector<pair<int,BranchLabelIndex>> c_list = CodeBuffer::merge($1.get_continue_list(), $2.get_continue_list());
                $$.set_break_list(b_list);
                $$.set_continue_list(c_list);
			}
;
Statement:	LBRACE OpenScope Statements CloseScope RBRACE{
				$$.set_type($3.get_type());

                //LLVM:
                $$.set_break_list($3.get_break_list());
                $$.set_continue_list($3.get_continue_list());
			}
			|Type ID SC{
				try{
					symbol_table.insert($2.get_id(), $1.get_type());
				}catch(Symbol_Table::ST_def& e){
					output::errorDef(yylineno, e.get_raised_id());
					exit(0);
				}

                //LLVM:
				$$.reset();
				$$.set_type("VOID");
				int offset = symbol_table.get_offset($2.get_id());
				string reg1 = freshVar();
				string str1 = reg1 + " = getelementptr i32, i32* %stack, i32 " + to_string(offset);
				code_buffer.emit(str1);
				string str2 = "store i32 0, i32* " + reg1;
				code_buffer.emit(str2);
				
			}
			|EnumType ID SC{
				try{
					symbol_table.insertEnumVar($2.get_id(),$1.get_type());
				}catch(Symbol_Table::ST_undefEnum& e){
				// the type doesnt exists
					output::errorUndefEnum(yylineno , e.get_raised_id());
					exit(0);
				}catch(Symbol_Table::ST_def& e){
				//the id exists:
					output::errorDef(yylineno, e.get_raised_id());
					exit(0);
				}

                //LLVM:
                $$.reset();
				$$.set_type("VOID");
				int offset = symbol_table.get_offset($2.get_id());
				string reg1 = freshVar();
				string str1 = reg1 + " = getelementptr i32, i32* %stack, i32 " + to_string(offset);
				code_buffer.emit(str1);
				string str2 = "store i32 0, i32* " + reg1;
				code_buffer.emit(str2);
			}
			|EnumDecl{
                //LLVM:
                $$.reset();
				$$.set_type("VOID");
			}
			|Type ID ASSIGN Exp SC{

				if ($1.get_type()!=$4.get_type() && !($4.get_type() == "BYTE" && $1.get_type() == "INT")){
					output::errorMismatch(yylineno);
					exit(0);
				}
				try{
					symbol_table.insert($2.get_id(), $1.get_type());
				}catch(Symbol_Table::ST_def& e){ // the id is used already
					output::errorDef(yylineno, e.get_raised_id());
					exit(0);
				}

				//LLVM:
				$$.reset();
				$$.set_type("VOID");
				int offset = symbol_table.get_offset($2.get_id());
				string reg1 = freshVar();
				string str1 = reg1 + " = getelementptr i32, i32* %stack, i32 " + to_string(offset);
				if ($1.get_type() != "BOOL") {
                    code_buffer.emit(str1);
                    string str2 = "store i32 " + $4.get_place() + ", i32* " + reg1;
                    code_buffer.emit(str2);
				}
				else {
				    string t_label = code_buffer.genLabel();
				    code_buffer.emit(str1);
                    string t_str = "store i32 1, i32* " + reg1;
                    code_buffer.emit(t_str);
                    int to_patch1 = code_buffer.emit("br label @");
				    string f_label = code_buffer.genLabel();
				    string reg2 = freshVar();
				    string str2 = reg2 + " = getelementptr i32, i32* %stack, i32 " + to_string(offset);
				    code_buffer.emit(str2);
                    string f_str = "store i32 0, i32* " + reg2;
                    code_buffer.emit(f_str);
                    int to_patch2 = code_buffer.emit("br label @");
                    string next = code_buffer.genLabel();
                    vector<pair<int,BranchLabelIndex>> list1 = CodeBuffer::makelist(pair<int,BranchLabelIndex>(to_patch1, FIRST));
                    vector<pair<int,BranchLabelIndex>> list2 = CodeBuffer::makelist(pair<int,BranchLabelIndex>(to_patch2, FIRST));
				    code_buffer.bpatch($4.get_true_list(), t_label);
				    code_buffer.bpatch($4.get_false_list(), f_label);
				    code_buffer.bpatch(list1, next);
				    code_buffer.bpatch(list2, next);
				}
			}
			|EnumType ID ASSIGN Exp SC{
				try{
					symbol_table.insertEnumVar($2.get_id(), $1.get_type(), $4.get_Val());
				}catch(Symbol_Table::ST_undefEnum& e){
				// if the enum type doesnt exist
					output::errorUndefEnum(yylineno , e.get_raised_id());
					exit(0);
				}catch(Symbol_Table::ST_def& e){
				// id already exists
					output::errorDef(yylineno, e.get_raised_id());
					exit(0);
				}catch(Symbol_Table::ST_undefEnumValue& e){
				//the value given to the variable isn't part of the enum type
					output::errorUndefEnumValue(yylineno,$2.get_id());
					exit(0);
				}
				if ($4.get_type() != $1.get_type()){
					output::errorUndefEnumValue(yylineno, $2.get_id());
					exit(0);
				}

                //LLVM:
                $$.reset();
				$$.set_type("VOID");
				int offset = symbol_table.get_offset($2.get_id());
				string reg1 = freshVar();
				string str1 = reg1 + " = getelementptr i32, i32* %stack, i32 " + to_string(offset);
				code_buffer.emit(str1);
				int enum_value = symbol_table.enum_to_num($4.get_Val());
				string str2 = "store i32 " + to_string(enum_value) + ", i32* " + reg1;
				code_buffer.emit(str2);
			}
			|ID ASSIGN Exp SC{
				try{
					if (symbol_table.get_datatype($1.get_id())!= ENUM_VAR && symbol_table.get_datatype($1.get_id()) != VAR){
						// if the id doesnt exist
						output::errorUndef(yylineno,$1.get_id());
						exit(0);
					}
					string type_of_id = symbol_table.get_var_type($1.get_id());
					if (symbol_table.get_datatype($1.get_id()) == ENUM_VAR && type_of_id != $3.get_type()){
						output::errorUndefEnumValue(yylineno,$1.get_id());
						exit(0);
					}
					if (type_of_id != $3.get_type() && !(type_of_id == "INT" && $3.get_type() == "BYTE")){
						output::errorMismatch(yylineno);
						exit(0);
					}
				}catch(Symbol_Table::ST_undef& e){
					// if the id doesnt exist
					output::errorUndef(yylineno,e.get_raised_id());
					exit(0);
				}

				//LLVM:
				$$.reset();
				$$.set_type("VOID");
				int offset = symbol_table.get_offset($1.get_id());
				string reg1 = freshVar();
				string str1 = reg1 + " = getelementptr i32, i32* %stack, i32 " + to_string(offset);
				if (symbol_table.get_var_type($1.get_id()) != "BOOL") {
                    code_buffer.emit(str1);
                    string str2 = "store i32 " + $3.get_place() + ", i32* " + reg1;
                    code_buffer.emit(str2);
				}
				else {
				    string t_label = code_buffer.genLabel();
				    code_buffer.emit(str1);
                    string t_str = "store i32 1, i32* " + reg1;
                    code_buffer.emit(t_str);
                    int to_patch1 = code_buffer.emit("br label @");
				    string f_label = code_buffer.genLabel();
				    string reg2 = freshVar();
				    string str2 = reg2 + " = getelementptr i32, i32* %stack, i32 " + to_string(offset);
				    code_buffer.emit(str2);
                    string f_str = "store i32 0, i32* " + reg2;
                    code_buffer.emit(f_str);
                    int to_patch2 = code_buffer.emit("br label @");
                    string next = code_buffer.genLabel();
                    vector<pair<int,BranchLabelIndex>> list1 = CodeBuffer::makelist(pair<int,BranchLabelIndex>(to_patch1, FIRST));
                    vector<pair<int,BranchLabelIndex>> list2 = CodeBuffer::makelist(pair<int,BranchLabelIndex>(to_patch2, FIRST));
				    code_buffer.bpatch($3.get_true_list(), t_label);
				    code_buffer.bpatch($3.get_false_list(), f_label);
				    code_buffer.bpatch(list1, next);
				    code_buffer.bpatch(list2, next);
				}
			}
			|Call SC{

				//LLVM:
				$$.reset();
				$$.set_type("VOID");

			}
			|RETURN SC{
				if (RetType_flag != "VOID"){
					output::errorMismatch(yylineno);
					exit(0);
				}

				//LLVM:
				$$.reset();
				$$.set_type("VOID");

			}
			|RETURN Exp SC{
				if ((RetType_flag != $2.get_type() && !( RetType_flag == "INT" && $2.get_type() == "BYTE")) || $2.get_type() == "VOID"){
					output::errorMismatch(yylineno);
					exit(0);
				}
				$$.set_type($2.get_type());

				//LLVM:
				$$.reset();
				if($2.get_type() != "BOOL")
				    code_buffer.emit("ret i32 " + $2.get_place());
				else {
                    string label1 = code_buffer.genLabel();
                    code_buffer.emit("ret i32 1");
                    string label2 = code_buffer.genLabel();
                    code_buffer.emit("ret i32 0");
                    code_buffer.bpatch($2.get_true_list(), label1);
                    code_buffer.bpatch($2.get_false_list(), label2);
				}
			}
			|IF LPAREN BoolExp RPAREN OpenScope M Statement CloseScope {
				$$.set_type($7.get_type());

				//LLVM:
				$$.set_break_list($7.get_break_list());
				$$.set_continue_list($7.get_continue_list());

				int to_patch = code_buffer.emit("br label @");
				vector<pair<int,BranchLabelIndex>> list = CodeBuffer::makelist(pair<int,BranchLabelIndex>(to_patch, FIRST));
                string my_label = code_buffer.genLabel();
                code_buffer.bpatch($3.get_true_list(), $6.get_quad());
                code_buffer.bpatch($3.get_false_list(), my_label);
                code_buffer.bpatch(list, my_label);

            	}
			|IF LPAREN BoolExp RPAREN OpenScope M Statement CloseScope ELSE N M OpenScope Statement CloseScope {
				$$.set_type2($7.get_type(), $13.get_type());

				//LLVM:
				vector<pair<int,BranchLabelIndex>> b_list = CodeBuffer::merge($7.get_break_list(), $13.get_break_list());
				vector<pair<int,BranchLabelIndex>> c_list = CodeBuffer::merge($7.get_continue_list(), $13.get_continue_list());
				$$.set_break_list(b_list);
				$$.set_continue_list(c_list);

				int to_patch = code_buffer.emit("br label @");
				vector<pair<int,BranchLabelIndex>> list = CodeBuffer::makelist(pair<int,BranchLabelIndex>(to_patch, FIRST));
				string my_label = code_buffer.genLabel();
                code_buffer.bpatch($3.get_true_list(), $6.get_quad());
                code_buffer.bpatch($3.get_false_list(), $11.get_quad());
                code_buffer.bpatch($10.get_next_list(), my_label);
                code_buffer.bpatch(list, my_label);
			}
			|WHILE N M LPAREN BoolExp RPAREN TurnOnWhile OpenScope M Statement N TurnOffWhile CloseScope{
				$$.set_type($10.get_type());

				//LLVM:
				$$.reset();
                string my_label = code_buffer.genLabel();
                code_buffer.bpatch($2.get_next_list(), $3.get_quad());
                code_buffer.bpatch($5.get_true_list(), $9.get_quad());
                code_buffer.bpatch($5.get_false_list(), my_label);
                code_buffer.bpatch($11.get_next_list(), $3.get_quad());

                code_buffer.bpatch($10.get_break_list(), my_label);
                code_buffer.bpatch($10.get_continue_list(), $3.get_quad());
			}
			|BREAK SC {
				if (while_flag == 0){
					output::errorUnexpectedBreak(yylineno);
					exit(0);
				}
				$$.set_type("VOID");

				//LLVM:
				$$.reset();
				int to_patch = code_buffer.emit("br label @");
				vector<pair<int,BranchLabelIndex>> list = CodeBuffer::makelist(pair<int,BranchLabelIndex>(to_patch, FIRST));
				$$.set_break_list(list);
				code_buffer.genLabel(); //necessary dummy
			}
			|CONTINUE SC {
				if (while_flag == 0){
					output::errorUnexpectedContinue(yylineno);
					exit(0);
				}
				$$.set_type("VOID");

				//LLVM:
				$$.reset();
				int to_patch = code_buffer.emit("br label @");
				vector<pair<int,BranchLabelIndex>> list = CodeBuffer::makelist(pair<int,BranchLabelIndex>(to_patch, FIRST));
				$$.set_continue_list(list);
				code_buffer.genLabel(); //necessary dummy

			}
;
Call:	ID LPAREN ExpList RPAREN{
			$$.reset();
			try{
				symbol_table.using_func($1.get_id(), $3.get_types_vector());
			}
			catch(Symbol_Table::ST_undefFunc& e){
			// the function doesn't exist
			output::errorUndefFunc(yylineno, e.get_raised_id());
			exit(0);
			}
			catch(Symbol_Table::ST_prototypeMismatch& e) {
			// there is prototypeMismatch
			output::errorPrototypeMismatch(yylineno, $1.get_id(), symbol_table.get_func_types($1.get_id()));
			exit(0);
			}
			$$.set_type(symbol_table.get_func_retType($1.get_id()));
			vector<Exp>& exp_list = $3.get_exp_list();
			string return_type = symbol_table.get_func_retType($1.get_id());
			if (return_type == "VOID"){
				return_type = "void";
			}
			else{
				return_type = "i32";
			}
			string type_of_param = "";
			if ($1.get_id()== "print"){
				type_of_param = "i8*";
			}
			else{
				type_of_param = "i32";
			}
			string places_list = "";
			for (int i = 0; i < exp_list.size(); i++ ) {
				places_list += type_of_param + " " + exp_list[i].get_place();
				if (i < exp_list.size() - 1){
					places_list += ", ";
				}
			}
			string str;
			if (return_type == "void") {
			    str = "call " + return_type + " @" + $1.get_id() + "(" + places_list + ")";
			    code_buffer.emit(str);
			    $$.set_place("NOT SUPPOSED TO BE HERE");
			}
			 else {
			    string reg = freshVar();
			    str = reg + " = " + "call " + return_type + " @" + $1.get_id() + "(" + places_list + ")";
			    code_buffer.emit(str);
			    $$.set_place(reg);
			    if (symbol_table.get_func_retType($1.get_id()) == "BOOL") {
                    string str2 = "br i1 " + reg + ", label @, label @";
                    int to_patch = code_buffer.emit(str2);
                    vector<pair<int,BranchLabelIndex>> t_list = CodeBuffer::makelist(pair<int,BranchLabelIndex>(to_patch, FIRST));
                    vector<pair<int,BranchLabelIndex>> f_list = CodeBuffer::makelist(pair<int,BranchLabelIndex>(to_patch, SECOND));
                    $$.set_true_list(t_list);
                    $$.set_false_list(f_list);
                }
			}
		}
		|ID LPAREN RPAREN{
			$$.reset();
			vector<string>* type_list = new vector<string>();
			try{
				symbol_table.using_func($1.get_id(), *type_list);
			}
			catch(Symbol_Table::ST_undefFunc& e){
			// the function doesn't exist
				output::errorUndefFunc(yylineno, e.get_raised_id());
				exit(0);
			}
			catch(Symbol_Table::ST_prototypeMismatch& e){
			//there is prototypeMismatch
				output::errorPrototypeMismatch(yylineno, $1.get_id(), symbol_table.get_func_types($1.get_id()));
				exit(0);
			}
			$$.set_type(symbol_table.get_func_retType($1.get_id()));
			string return_type = symbol_table.get_func_retType($1.get_id());
			if (return_type == "VOID"){
				return_type = "void";
			}
			else{
				return_type = "i32";
			}
            string str;
			if (return_type == "void") {
			    str = "call " + return_type + " @" + $1.get_id() + "()";
			    code_buffer.emit(str);
			    $$.set_place("NOT SUPPOSED TO BE HERE");
			}
			 else {
			    string reg = freshVar();
			    str = reg + " = " + "call " + return_type + " @" + $1.get_id() + "()";
			    code_buffer.emit(str);
			    $$.set_place(reg);
			    if (symbol_table.get_func_retType($1.get_id()) == "BOOL") {
                    string reg2 = freshVar();
                    string str2 = reg2 + " = trunc i32 " + reg + " to i1";
                    code_buffer.emit(str2);
                    string str3 = "br i1 " + reg2 + ", label @, label @";
                    int to_patch = code_buffer.emit(str3);
                    vector<pair<int,BranchLabelIndex>> t_list = CodeBuffer::makelist(pair<int,BranchLabelIndex>(to_patch, FIRST));
                    vector<pair<int,BranchLabelIndex>> f_list = CodeBuffer::makelist(pair<int,BranchLabelIndex>(to_patch, SECOND));
                    $$.set_true_list(t_list);
                    $$.set_false_list(f_list);
                }
			}
		}
;
ExpList:	Exp{
				$$.reset();
				if ($1.get_type() == "BOOL") {
                    string label1 = code_buffer.genLabel();
                    int br1 = code_buffer.emit("br label @");
                    string label2 = code_buffer.genLabel();
                    int br2 = code_buffer.emit("br label @");
                    string label3 = code_buffer.genLabel();
                    string reg = freshVar();
                    string phi_str = reg + " = phi i32 [ 1, %" + label1 + " ], [ 0, %" + label2 + " ]";
                    code_buffer.emit(phi_str);
                    vector<pair<int,BranchLabelIndex>> list1 = CodeBuffer::makelist(pair<int,BranchLabelIndex>(br1, FIRST));
                    vector<pair<int,BranchLabelIndex>> list2 = CodeBuffer::makelist(pair<int,BranchLabelIndex>(br2, FIRST));
                    code_buffer.bpatch($1.get_true_list(), label1);
                    code_buffer.bpatch($1.get_false_list(), label2);
                    code_buffer.bpatch(list1, label3);
                    code_buffer.bpatch(list2, label3);
                    $1.set_place(reg);  //Hope it is not a problem
				}
				$$.insert($1);
			}
			|Exp COMMA {
				if ($1.get_type() == "BOOL") {
                    string label1 = code_buffer.genLabel();
                    int br1 = code_buffer.emit("br label @");
                    string label2 = code_buffer.genLabel();
                    int br2 = code_buffer.emit("br label @");
                    string label3 = code_buffer.genLabel();
                    string reg = freshVar();
                    string phi_str = reg + " = phi i32 [ 1, %" + label1 + " ], [ 0, %" + label2 + " ]";
                    code_buffer.emit(phi_str);
                    vector<pair<int,BranchLabelIndex>> list1 = CodeBuffer::makelist(pair<int,BranchLabelIndex>(br1, FIRST));
                    vector<pair<int,BranchLabelIndex>> list2 = CodeBuffer::makelist(pair<int,BranchLabelIndex>(br2, FIRST));
                    code_buffer.bpatch($1.get_true_list(), label1);
                    code_buffer.bpatch($1.get_false_list(), label2);
                    code_buffer.bpatch(list1, label3);
                    code_buffer.bpatch(list2, label3);
                    $1.set_place(reg);  //Hope it is not a problem
				}
			} ExpList{
				$$.reset();
				$$.join_lists($4);
				$$.insert($1);
			}
;
Type:	INT{
			$$.set_type("INT");
		}
		|BYTE{
			$$.set_type("BYTE");
		}
		|BOOL{
			$$.set_type("BOOL");
		}
;
EnumType:	ENUM ID{
				$$.set_type($2.get_id());
			}
;
Exp:	LPAREN Exp RPAREN{
			$$.reset();
			$$.set_type($2.get_type());

			//LLVM:
			if($2.get_type() != "BOOL")
			    $$.set_place($2.get_place());
			$$.set_true_list($2.get_true_list());
			$$.set_false_list($2.get_false_list());
		}
		|Exp BINOP_MUL Exp{
			$$.reset();
			if (($1.get_type()!="INT" && $1.get_type()!="BYTE") || ($3.get_type()!="INT" && $3.get_type()!="BYTE")){
				output::errorMismatch(yylineno);
				exit(0);
			}
			if ($1.get_type() == "INT" || $3.get_type() == "INT"){
				$$.set_type("INT");
			}
			else{
				$$.set_type("BYTE");
			}
			string new_place = freshVar();
			$$.set_place(new_place);
			const string my_string3 =  new_place + " = mul i32 " + $1.get_place() + ", " + $3.get_place();
			code_buffer.emit(my_string3);
		}
		|Exp BINOP_DIV Exp{
			$$.reset();
			if (($1.get_type()!="INT" && $1.get_type()!="BYTE") || ($3.get_type()!="INT" && $3.get_type()!="BYTE")){
				output::errorMismatch(yylineno);
				exit(0);
			}
			if ($1.get_type() == "INT" || $3.get_type() == "INT"){
				$$.set_type("INT");
			}
			else{
				$$.set_type("BYTE");
			}
			string div_0_reg = freshVar();
			code_buffer.emit(div_0_reg + " = icmp eq i32 0, " + $3.get_place());
			int bp_address = code_buffer.emit("br i1 " + div_0_reg + ", label @, label @");
			vector<pair<int,BranchLabelIndex>> list_exit = CodeBuffer::makelist(pair<int,BranchLabelIndex>(bp_address, FIRST));
			vector<pair<int,BranchLabelIndex>> list_next = CodeBuffer::makelist(pair<int,BranchLabelIndex>(bp_address, SECOND));
			string label_exit = code_buffer.genLabel();
			code_buffer.emit("call void @exit(i32 1)");
			int to_patch = code_buffer.emit("br label @");
			vector<pair<int,BranchLabelIndex>> list_redundant = CodeBuffer::makelist(pair<int,BranchLabelIndex>(to_patch, FIRST));
			string my_label = code_buffer.genLabel();
			code_buffer.bpatch(list_exit, label_exit);
			code_buffer.bpatch(list_next, my_label);
			code_buffer.bpatch(list_redundant, my_label);
			string new_place = freshVar();
			$$.set_place(new_place);
			string my_string3 =  new_place + " = sdiv i32 " + $1.get_place() + ", " + $3.get_place();
			code_buffer.emit(my_string3);
		}
		|Exp BINOP_ADD Exp{
			$$.reset();
			if (($1.get_type()!="INT" && $1.get_type()!="BYTE") || ($3.get_type()!="INT" && $3.get_type()!="BYTE")){
				output::errorMismatch(yylineno);
				exit(0);
			}
			if ($1.get_type() == "INT" || $3.get_type() == "INT"){
				$$.set_type("INT");
			}
			else{
				$$.set_type("BYTE");
			}
			string new_place = freshVar();
			$$.set_place(new_place);
			const string my_string3 =  new_place + " = add i32 " + $1.get_place() + ", " + $3.get_place();
			code_buffer.emit(my_string3);
		}
		|Exp BINOP_SUB Exp{
			$$.reset();
			if (($1.get_type()!="INT" && $1.get_type()!="BYTE") || ($3.get_type()!="INT" && $3.get_type()!="BYTE")){
				output::errorMismatch(yylineno);
				exit(0);
			}
			if ($1.get_type() == "INT" || $3.get_type() == "INT"){
				$$.set_type("INT");
			}
			else{
				$$.set_type("BYTE");
			}
			string new_place = freshVar();
			$$.set_place(new_place);
			const string my_string3 =  new_place + " = sub i32 " + $1.get_place() + ", " + $3.get_place();
			code_buffer.emit(my_string3);
		}
		|ID{
			$$.reset();
			try{
				$$.set_type(symbol_table.get_var_type($1.get_id()));
			}catch(Symbol_Table::ST_undef& e){
				output::errorUndef(yylineno, e.get_raised_id());
				exit(0);
			}
			$$.set_Val($1.get_id());
			string type = symbol_table.get_var_type($1.get_id());
			string i_type;
			if (type == "BOOL") {
			    i_type = "i1";
			}
			else if (type == "BYTE") {
				i_type = "i8";
			}
			else if(type == "INT") {
				i_type = "i32";
			}
			else {
			    i_type = "ERROR!!!";
			}
			int offset = symbol_table.get_offset($1.get_id());
			string reg1 = freshVar();
			const string str1 = reg1 + " = getelementptr i32, i32* %stack, i32 " + to_string(offset);
			code_buffer.emit(str1);
			string reg2 = freshVar();
			string str2 = reg2 + " = load i32, i32* " + reg1;
			code_buffer.emit(str2);
			if (type == "BOOL") {
                string reg3 = freshVar();
                string str3 = reg3 + " = trunc i32 " + reg2 + " to i1";
                code_buffer.emit(str3);
                string str4 = "br i1 " + reg3 + ", label @, label @";
                int to_patch = code_buffer.emit(str4);
                vector<pair<int,BranchLabelIndex>> t_list = CodeBuffer::makelist(pair<int,BranchLabelIndex>(to_patch, FIRST));
                vector<pair<int,BranchLabelIndex>> f_list = CodeBuffer::makelist(pair<int,BranchLabelIndex>(to_patch, SECOND));
                $$.set_true_list(t_list);
                $$.set_false_list(f_list);
            }
			$$.set_place(reg2);
		}
		|Call{
			$$.reset();
			$$.set_type($1.get_type());
            $$.set_place($1.get_place());
            $$.set_true_list($1.get_true_list());
            $$.set_false_list($1.get_false_list());

		}
		|NUM{
			$$.reset();
			$$.set_Val($1.get_value());
			$$.set_type("INT");
			$$.set_place($1.get_value());
		}
		|NUM B {
			$$.reset();
			$$.set_Val($1.get_value());
			if ($1.get_type() != "BYTE"){
				output::errorByteTooLarge(yylineno, $1.get_value());
				exit(0);
			}
			$$.set_type("BYTE");
			$$.set_place($1.get_value());
		}
		|STRING {
			$$.reset();
			$$.set_type("STRING");
			string new_num = freshNum();
			code_buffer.emitGlobal("@.str" + new_num + " = constant [" + to_string($1.get_value().size()) + " x i8] c" + $1.get_value().substr(0,$1.get_value().size() -1) + "\\0A\\00\"");
			string register_that_keep_the_value = freshVar();
			code_buffer.emit(register_that_keep_the_value + " = getelementptr [" + to_string($1.get_value().size()) + " x i8], [" + to_string($1.get_value().size()) + " x i8]* @.str" + new_num + ", i32 0, i32 0");
			$$.set_place(register_that_keep_the_value);
		}
		|LPAREN Type RPAREN Exp {
			$$.reset();
			try{
			if((symbol_table.get_datatype($4.get_Val()) != ENUM_VAR) && (symbol_table.get_datatype($4.get_Val()) != ENUM_VAL)) {
				output::errorMismatch(yylineno);
				exit(0);
			}
			}catch(Symbol_Table::ST_undef& e) {
                output::errorUndef(yylineno, e.get_raised_id());
              	exit(0);
            }
			if ($2.get_type() != "INT"){
				output::errorMismatch(yylineno);
         		exit(0);
			}
			$$.set_type("INT");
			$$.set_place($4.get_place());
		}
		|TRUE {
			$$.reset();
			$$.set_type("BOOL");

			//LLVM:
            int to_patch = code_buffer.emit("br label @");
            vector<pair<int,BranchLabelIndex>> list = CodeBuffer::makelist(pair<int,BranchLabelIndex>(to_patch, FIRST));
            $$.set_true_list(list);

		}
		|FALSE {
			$$.reset();
			$$.set_type("BOOL");

			//LLVM:
            int to_patch = code_buffer.emit("br label @");
            vector<pair<int,BranchLabelIndex>> list = CodeBuffer::makelist(pair<int,BranchLabelIndex>(to_patch, FIRST));
            $$.set_false_list(list);

		}
		|NOT Exp {
			$$.reset();
			if ($2.get_type() != "BOOL") {
				output::errorMismatch(yylineno);
         		exit(0);
			}
			$$.set_type("BOOL");

			//LLVM:
			    $$.set_true_list($2.get_false_list());
			    $$.set_false_list($2.get_true_list());
		}
		|Exp AND M Exp {
			$$.reset();
			if ($1.get_type() != "BOOL" || $4.get_type() != "BOOL") {
				output::errorMismatch(yylineno);
         		exit(0);
			}
			$$.set_type("BOOL");

            //LLVM:
            code_buffer.bpatch($1.get_true_list(), $3.get_quad());
            vector<pair<int,BranchLabelIndex>> e1_f = $1.get_false_list();
            vector<pair<int,BranchLabelIndex>> e2_f = $4.get_false_list();
            vector<pair<int,BranchLabelIndex>> f_list = CodeBuffer::merge(e1_f, e2_f);
            $$.set_true_list($4.get_true_list());
            $$.set_false_list(f_list);
		}
		|Exp OR M Exp {
			$$.reset();
			if ($1.get_type() != "BOOL" || $4.get_type() != "BOOL") {
				output::errorMismatch(yylineno);
         		exit(0);
			}
			$$.set_type("BOOL");

            //LLVM:
            code_buffer.bpatch($1.get_false_list(), $3.get_quad());
            vector<pair<int,BranchLabelIndex>> e1_t = $1.get_true_list();
            vector<pair<int,BranchLabelIndex>> e2_t = $4.get_true_list();
            vector<pair<int,BranchLabelIndex>> t_list = CodeBuffer::merge(e1_t, e2_t);
            $$.set_true_list(t_list);
            $$.set_false_list($4.get_false_list());
		}
		|Exp RELOP_EQ Exp {
			$$.reset();
			if (($1.get_type() != "INT" && $1.get_type() != "BYTE") || ($3.get_type() != "INT" && $3.get_type() != "BYTE")) {
				output::errorMismatch(yylineno);
         		exit(0);
			}
			$$.set_type("BOOL");

			//LLVM:
			string reg = freshVar();
			string str1 = reg + " = icmp eq i32 " + ($1.get_place()) + ", " + ($3.get_place());
			int line = code_buffer.emit(str1);
            $$.set_place(reg);

			string str2 = "br i1 " + reg + ", label @, label @";
            int to_patch = code_buffer.emit(str2);
            vector<pair<int,BranchLabelIndex>> t_list = CodeBuffer::makelist(pair<int,BranchLabelIndex>(to_patch, FIRST));
			vector<pair<int,BranchLabelIndex>> f_list = CodeBuffer::makelist(pair<int,BranchLabelIndex>(to_patch, SECOND));
			$$.set_true_list(t_list);
            $$.set_false_list(f_list);

		}
		|Exp RELOP_NE Exp {
        	$$.reset();
        	if (($1.get_type() != "INT" && $1.get_type() != "BYTE") || ($3.get_type() != "INT" && $3.get_type() != "BYTE")) {
        		output::errorMismatch(yylineno);
               	exit(0);
        	}
        	$$.set_type("BOOL");

			//LLVM:
			string reg = freshVar();
			string str1 = reg + " = icmp ne i32 " + ($1.get_place()) + ", " + ($3.get_place());
			int line = code_buffer.emit(str1);
            $$.set_place(reg);

			string str2 = "br i1 " + reg + ", label @, label @";
            int to_patch = code_buffer.emit(str2);
            vector<pair<int,BranchLabelIndex>> t_list = CodeBuffer::makelist(pair<int,BranchLabelIndex>(to_patch, FIRST));
			vector<pair<int,BranchLabelIndex>> f_list = CodeBuffer::makelist(pair<int,BranchLabelIndex>(to_patch, SECOND));
			$$.set_true_list(t_list);
            $$.set_false_list(f_list);
        }
		|Exp RELOP_LT Exp {
			$$.reset();
			if (($1.get_type()!= "INT" && $1.get_type()!= "BYTE") || ($3.get_type()!= "INT" && $3.get_type()!= "BYTE")){
				output::errorMismatch(yylineno);
         		exit(0);
			}
			$$.set_type("BOOL");

			//LLVM:
			string reg = freshVar();
			string str1, str2;
			if ($1.get_type() == "BYTE" && $3.get_type() == "BYTE")
			    str1 = reg + " = icmp ult i32 " + ($1.get_place()) + ", " + ($3.get_place());
			else
			    str1 = reg + " = icmp slt i32 " + ($1.get_place()) + ", " + ($3.get_place());
			int line = code_buffer.emit(str1);
            $$.set_place(reg);

			str2 = "br i1 " + reg + ", label @, label @";
            int to_patch = code_buffer.emit(str2);
            vector<pair<int,BranchLabelIndex>> t_list = CodeBuffer::makelist(pair<int,BranchLabelIndex>(to_patch, FIRST));
			vector<pair<int,BranchLabelIndex>> f_list = CodeBuffer::makelist(pair<int,BranchLabelIndex>(to_patch, SECOND));
			$$.set_true_list(t_list);
            $$.set_false_list(f_list);
		}
		|Exp RELOP_GT Exp {
			$$.reset();
			if (($1.get_type()!= "INT" && $1.get_type()!= "BYTE") || ($3.get_type()!= "INT" && $3.get_type()!= "BYTE")){
				output::errorMismatch(yylineno);
         		exit(0);
			}
			$$.set_type("BOOL");

			//LLVM:
			string reg = freshVar();
			string str1, str2;
			if ($1.get_type() == "BYTE" && $3.get_type() == "BYTE")
			    str1 = reg + " = icmp ugt i32 " + ($1.get_place()) + ", " + ($3.get_place());
			else
			    str1 = reg + " = icmp sgt i32 " + ($1.get_place()) + ", " + ($3.get_place());
			int line = code_buffer.emit(str1);
            $$.set_place(reg);

			str2 = "br i1 " + reg + ", label @, label @";
            int to_patch = code_buffer.emit(str2);
            vector<pair<int,BranchLabelIndex>> t_list = CodeBuffer::makelist(pair<int,BranchLabelIndex>(to_patch, FIRST));
			vector<pair<int,BranchLabelIndex>> f_list = CodeBuffer::makelist(pair<int,BranchLabelIndex>(to_patch, SECOND));
			$$.set_true_list(t_list);
            $$.set_false_list(f_list);
		}
		|Exp RELOP_LE Exp {
			$$.reset();
			if (($1.get_type()!= "INT" && $1.get_type()!= "BYTE") || ($3.get_type()!= "INT" && $3.get_type()!= "BYTE")){
				output::errorMismatch(yylineno);
         		exit(0);
			}
			$$.set_type("BOOL");

			//LLVM:
			string reg = freshVar();
			string str1, str2;
			if ($1.get_type() == "BYTE" && $3.get_type() == "BYTE")
			    str1 = reg + " = icmp ule i32 " + ($1.get_place()) + ", " + ($3.get_place());
			else
			    str1 = reg + " = icmp sle i32 " + ($1.get_place()) + ", " + ($3.get_place());
			int line = code_buffer.emit(str1);
            $$.set_place(reg);

			str2 = "br i1 " + reg + ", label @, label @";
            int to_patch = code_buffer.emit(str2);
            vector<pair<int,BranchLabelIndex>> t_list = CodeBuffer::makelist(pair<int,BranchLabelIndex>(to_patch, FIRST));
			vector<pair<int,BranchLabelIndex>> f_list = CodeBuffer::makelist(pair<int,BranchLabelIndex>(to_patch, SECOND));
			$$.set_true_list(t_list);
            $$.set_false_list(f_list);
		}
		|Exp RELOP_GE Exp {
			$$.reset();
			if (($1.get_type()!= "INT" && $1.get_type()!= "BYTE") || ($3.get_type()!= "INT" && $3.get_type()!= "BYTE")){
				output::errorMismatch(yylineno);
         		exit(0);
			}
			$$.set_type("BOOL");

			//LLVM:
			string reg = freshVar();
			string str1 ,str2;
			if ($1.get_type() == "BYTE" && $3.get_type() == "BYTE")
			    str1 = reg + " = icmp uge i32 " + ($1.get_place()) + ", " + ($3.get_place());
			else
			    str1 = reg + " = icmp sge i32 " + ($1.get_place()) + ", " + ($3.get_place());
			int line = code_buffer.emit(str1);
            $$.set_place(reg);

			str2 = "br i1 " + reg + ", label @, label @";
            int to_patch = code_buffer.emit(str2);
            vector<pair<int,BranchLabelIndex>> t_list = CodeBuffer::makelist(pair<int,BranchLabelIndex>(to_patch, FIRST));
			vector<pair<int,BranchLabelIndex>> f_list = CodeBuffer::makelist(pair<int,BranchLabelIndex>(to_patch, SECOND));
			$$.set_true_list(t_list);
            $$.set_false_list(f_list);
		}
;
BoolExp: Exp {
            $$.reset();
			if ($1.get_type() != "BOOL") {
				output::errorMismatch(yylineno);
				exit(0);
				}

			//LLVM:
			    $$.set_true_list($1.get_true_list());
			    $$.set_false_list($1.get_false_list());
            }
;
InsertFunc:	/*epsilon*/ {
				while_flag = 0;
				vector<string> param1 = {"STRING"};
				vector<string> param2 = {"INT"};
				symbol_table.insertFunc("print", "VOID", param1);
				symbol_table.insertFunc("printi", "VOID", param2);

				//LLVM:
				code_buffer.emitGlobal("declare i32 @printf(i8*, ...)");
				code_buffer.emitGlobal("declare void @exit(i32)");
				code_buffer.emitGlobal("@.int_specifier = constant [4 x i8] c\"%d\\0A\\00\"");
				code_buffer.emitGlobal("define void @printi(i32) {");
				code_buffer.emitGlobal("call i32 (i8*, ...) @printf(i8* getelementptr ([4 x i8], [4 x i8]* @.int_specifier, i32 0, i32 0), i32 %0)");
				code_buffer.emitGlobal("ret void");
				code_buffer.emitGlobal("}");
				code_buffer.emitGlobal("define void @print(i8*) {");
				code_buffer.emitGlobal("call i32 (i8*, ...) @printf(i8* %0)");
				code_buffer.emitGlobal("ret void");
				code_buffer.emitGlobal("}");
			}
;
OpenScope: /*epsilon*/ {
			symbol_table.openScope();
		}
;
CloseScope: /*epsilon*/ {
	try{
			symbol_table.closeScope();
		}catch(Symbol_Table::ST_empty){
			printf("wrong go out");
			exit(0);
		}
}
;
TurnOnWhile: /*epsilon*/ {
			while_flag++;
		}
;
TurnOffWhile: /*epsilon*/ {
			while_flag--;
		}
;

M: /*epsilon*/ {
            string str = code_buffer.genLabel();
			$$.set_quad(str);
		}
;

N: /*epsilon*/ {
			int next = code_buffer.emit("br label @");
			vector<pair<int,BranchLabelIndex>> new_list = CodeBuffer::makelist(pair<int,BranchLabelIndex>(next, FIRST));
            $$.set_next_list(new_list);
		}
;
%%

int yyerror(const char * message) {
		output::errorSyn(yylineno);
		exit(0);
	}


int main() {
	int y = yyparse();
	code_buffer.printGlobalBuffer();
	code_buffer.printCodeBuffer();
	return y;
}